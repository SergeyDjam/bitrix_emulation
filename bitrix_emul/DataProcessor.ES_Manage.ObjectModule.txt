Перем ВнутреннийКэш;//Соответствие

Функция ПараметрыСоединенияES()
	Возврат Новый Структура("Сервер,Порт","localhost",9200);
КонецФункции

Функция СтрокаСоединенияES() Экспорт
	Возврат "http://localhost:9200/";
КонецФункции

Функция СоединениеES()
	
	Результат = ЭДО_Кэш_Прочитать("СоединениеES");
	
	Если Результат=Неопределено Тогда
		
		Сервер	= ПараметрыСоединенияES().Сервер;
		Порт	= ПараметрыСоединенияES().Порт;
		
		//Сервер = "localhost";
		Прокси = Неопределено;
		
		//Порт = 443;
		//ЗащищенноеСоединение = Истина;//для 8.3 будет по-другому. Точнее, на месте этого параметра будет стоять таймаут. Бред, короче.
		
		//Порт = 80;
		ЗащищенноеСоединение = Ложь;//для 8.3 будет по-другому. Точнее, на месте этого параметра будет стоять таймаут. Бред, короче.
		
		Если МетодРаботыAPI() = "Native" Тогда
			
//			Результат = Новый HTTPСоединение(Сервер, Порт, , , Прокси, , Новый ЗащищенноеСоединениеOpenSSL);
			Результат = Новый HTTPСоединение(Сервер, Порт, , , Прокси, , );
		
		ИначеЕсли МетодРаботыAPI() = "COM" Тогда	
			
			Результат = Новый COMОбъект("WinHttp.WinHttpRequest.5.1");
			//Результат.Option(2,"UTF-8");                   
		
		КонецЕсли;
		
//		Результат = Новый HTTPСоединение(Сервер, Порт, , , Прокси, ЗащищенноеСоединение);
		ЭДО_Кэш_Поместить("СоединениеES",Результат);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ЭДО_Кэш_Прочитать(ИмяЗначения)
	
	Если ВнутреннийКэш = Неопределено Тогда
		Возврат Неопределено;
	Иначе
		Возврат ВнутреннийКэш.Получить(ИмяЗначения);
	КонецЕсли;
	
КонецФункции

Процедура ЭДО_Кэш_Поместить(ИмяЗначения,Значение)
	
	Если ВнутреннийКэш = Неопределено Тогда
		ВнутреннийКэш = Новый Соответствие;
	КонецЕсли;
	
	ВнутреннийКэш.Вставить(ИмяЗначения,Значение);
	
КонецПроцедуры

Функция EDI_РазложитьСтрокуВМассивСлов(Знач Строка, РазделителиСлов="") Экспорт
	
	Слова = Новый Массив;
	
	Для Сч = 1 По СтрДлина(РазделителиСлов) Цикл
		Строка = СтрЗаменить(Строка,Сред(РазделителиСлов,Сч,1),Символы.ПС);
	КонецЦикла;
	
	Для Сч=1 По СтрЧислоСтрок(Строка) Цикл
		ТекСлово = СокрЛП(СтрПолучитьСтроку(Строка,Сч));
		Если ТекСлово<>"" Тогда
			Слова.Добавить(ТекСлово);
		КонецЕсли;	
	КонецЦикла;	
	
	Возврат Слова;
	
КонецФункции


//платформы ниже 8.3 придется заворачивать на WinHTTPRequest через COM
Функция API_ВызватьМетод(АдресЗапроса,Метод,УчетнаяЗапись,ТекстФайла="") Экспорт
	
	Результат = Неопределено;
	
	ИмяФайлаОтвета=ПолучитьИмяВременногоФайла();
	
	Заголовки = Новый Соответствие;
	//Заголовки.Вставить("Accept","application/json");//без этого вернется протобуфер
	//Заголовки.Вставить("Content-Type","application/json; charset=utf-8");//для отправки в JSON вместо protobuf
	
	Результат = _СобственноВыполнениеЗапроса(СоединениеES(),АдресЗапроса,"",Заголовки,Метод,ТекстФайла);
	
	Возврат Результат;
	
КонецФункции	

Функция РазобратьОтвет(Ответ) Экспорт
	
	ИмяВремФайла = ПолучитьИмяВременногоФайла();
	ТД = Новый ТекстовыйДокумент;
	ТД.УстановитьТекст(Ответ);
	ТД.Записать(ИмяВремФайла,"UTF-8");
	
	Чтение = Новый ЧтениеJSON;
//	Чтение.УстановитьСтроку(Ответ);
	Чтение.ОткрытьФайл(ИмяВремФайла,"UTF-8");
	Результат = ПрочитатьJSON(Чтение);
	Чтение.Закрыть();

	УдалитьФайлы(ИмяВремФайла);
	
	Возврат Результат;
	
КонецФункции

Функция _СобственноВыполнениеЗапроса(Соединение,АдресЗапроса,Параметры="",Заголовки,Метод,ТекстФайла="")//ТекстФайла - для POST
	
	Результат = Неопределено;
	ПолныйАдрес = АдресЗапроса+?(Параметры="","","?")+Параметры;
	ИмяФайлаОтвета = ПолучитьИмяВременногоФайла();
	
	Если МетодРаботыAPI()="Native" Тогда
		
		Если Метод = "GET" Тогда
			Соединение.Получить(ПолныйАдрес,ИмяФайлаОтвета,Заголовки);
		ИначеЕсли Метод = "DELETE" Тогда
			_Запрос = Новый HTTPЗапрос;
			_Запрос.АдресРесурса = ПолныйАдрес;
			_Запрос.Заголовки = Заголовки;
			
			//Соединение.Удалить(ПолныйАдрес,ИмяФайлаОтвета,Заголовки);
			Соединение.Удалить(_Запрос);
		ИначеЕсли Метод = "POST" Тогда
			
			_Запрос = Новый HTTPЗапрос(ПолныйАдрес);
			_Запрос.УстановитьТелоИзСтроки(ТекстФайла,"UTF-8",ИспользованиеByteOrderMark.НеИспользовать);//BOM обязательно отключить!
			_Запрос.Заголовки = Заголовки;
			
			Соединение.ОтправитьДляОбработки(_Запрос,ИмяФайлаОтвета);
			
		КонецЕсли;
		
		ТД=Новый ТекстовыйДокумент;
		ТД.Прочитать(ИмяФайлаОтвета,КодировкаТекста.UTF8);
		Результат=ТД.ПолучитьТекст();
		
		//НачатьУдалениеФайлов(,ИмяФайлаОтвета);
		УдалитьФайлы(ИмяФайлаОтвета);
		
	ИначеЕсли МетодРаботыAPI()="COM" Тогда
		
		АдресАпи = "https://diadoc-api.kontur.ru";
		Соединение.Open(Метод,АдресАпи+ПолныйАдрес,0);
		 
		Для Каждого Заголовок Из Заголовки Цикл
			Соединение.SetRequestHeader(Заголовок.Ключ, Заголовок.Значение);
		КонецЦикла;
		        
		Соединение.Send(ТекстФайла);// Параметром передаем POST-данные для страници тут как раз
		Результат = Соединение.ResponseText();
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

//просто добавляет переносы строк в JSON
Функция ЧитабельныйОтвет(Ответ) Экспорт
	Результат = Ответ;
	
	Для Каждого Символ Из EDI_РазложитьСтрокуВМассивСлов("{ ["," ") Цикл
		Результат = СтрЗаменить(Результат,Символ,Символы.ПС+Символ);
	КонецЦикла;
	
	Для Каждого Символ Из EDI_РазложитьСтрокуВМассивСлов("} ]"," ") Цикл
		Результат = СтрЗаменить(Результат,Символ,Символ+Символы.ПС);
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

Функция МетодРаботыAPI()
	
	Возврат "Native";
	//Возврат "COM";

КонецФункции


Функция ES_API_SearchIndexes(boxId,messageId,entityId="") Экспорт
	
	_Параметры = "boxId="+boxId+"&messageId="+messageId;
	Если Не ПустаяСтрока(entityId) Тогда
		_Параметры = _Параметры+"&entityId="+entityId;
	КонецЕсли;
	
	Возврат API_ВызватьМетод("/V3/GetMessage?"+_Параметры,"GET","","");
	
КонецФункции

Функция ES_API_Goods_Create(id,RequestBody) Экспорт
	//да, и тут не хватает владельца: чей каталог создаем/обновляем.
	
	//вот здесь, кажется, имеет смысл брать составной id: guid каталога и guid товара. Может, еще плюсом guid владельца.	
	Возврат API_ВызватьМетод("/mybase/goods/"+id,"POST","",RequestBody);
	
	//возможно, имеет смысл "goods" сделать отдельным индексом, а каждый каталог внутри него - уже отдельным типом. А "mybase" вообще исключить
	//или еще один вариант: под каждый каталог (или владельца) заводить отдельный тип, а внутри него уже товары (элементы).
	
	//Т.е. варианты:
	// 1)
	// /goods/<id каталога>/items
	// /cats/<id каталога>/схема каталога (названия полей, ...)
	// /owners/<id владельца>/???
	
	//2) (как сейчас, и похоже на реляционку. Наличие "mybase" кажется лишним)
	// /mybase/goods/<good's id>
	// /mybase/owners/<owner's id>
	// /mybase/cats/<cat's id>
	
КонецФункции

Функция СтрокаТаблицыВСтруктуру(СтрокаТаблицы) Экспорт
	
	Результат = Новый Структура;
	
	Для Каждого Колонка Из СтрокаТаблицы.Владелец().Колонки Цикл
		Результат.Вставить(Колонка.Имя,СтрокаТаблицы[Колонка.Имя]);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция СтруктураВJSON(Структура) Экспорт
	
	Запись = Новый ЗаписьJSON;
	Запись.УстановитьСтроку();
	
	ЗаписатьJSON(Запись,Структура);
	
	Результат = Запись.Закрыть();
	
	Возврат Результат;
	
КонецФункции	

//брехня
Функция Описание()
	
	//ES имеет структуру:
	//http://localhost:9200/<индекс>/<тип>/<элемент>
	
	//где <индекс> - вроде БД
	//<тип> - таблица
	//<элемент> - запись в таблице
	
	
	//значит, у нас будут типы:
	//1. Просто товары с полями: Владелец, Каталог, GTIN, Код, Наименование и т.д.
	//2. Каталоги с полями: Владелец, Наименование, [теги] (?)
	//3. Владельцы с полями: Наименование, ИНН, КПП, [теги] (?)
	
	
	
	//как обработать входящий каталог CML?
	//1. Создать владельца и каталог, видимо.
	//2. Разобранные товары кинуть в ES. Что там с обновлениями? Как избегать конфликтов?
	
	//дак вот, разбор можно той обработкой.
	
	
	
	
	
	
	//**************************************************************//
	
	
	//теперь подумаем над API
	
	//надо уметь делать такие вещи:
	//1) Поиск описания товара (название, GTIN, ...) в различных каталогах
	//2) Вывод самих каталогов в CML. Т.е. преобразование кучи записей ES в CommerceML
	//3) Вывод списка зарегистрированных компаний
	//4) А также какой-то механизм регистрации
	
	
	//и еще одна проблема сразу: состав полей в разных каталогах разный, но при этом тип "goods" у нас один и тот же. Видимо, доп.поля будем отдельными тегами делать.
	
КонецФункции	

Процедура ПоместитьКаталогВЭластик(ИмяФайлаПримера,Парсер) Экспорт
	
	Таблицы = Парсер.РазобратьXMLВТаблицыЗначений(ИмяФайлаПримера);
	
	СтрокаОсновныхПолей = "";
	СтрокаПроизвольныхПолей = "";
	
	Для Каждого КолонкаТоваров Из Таблицы.ТаблицаТоваров.Колонки Цикл
		
		//соберем строку, после чего разобьем ТаблицаТоваров пополам
		
		Если Таблицы.СтруктураДопПолей.Найти(КолонкаТоваров.Имя,"ВнутреннееИмя")=Неопределено Тогда
			СтрокаОсновныхПолей = ?(СтрокаОсновныхПолей="","",СтрокаОсновныхПолей+",")+КолонкаТоваров.Имя;//основное поле
		Иначе	
			СтрокаПроизвольныхПолей = ?(СтрокаПроизвольныхПолей="","",СтрокаПроизвольныхПолей+",")+КолонкаТоваров.Имя;//произвольное поле
		КонецЕсли;	
		
	КонецЦикла;	
	
	ТаблицаОсновныхПолей = Таблицы.ТаблицаТоваров.Скопировать(,СтрокаОсновныхПолей);
	ТаблицаПроизвольныхПолей = Таблицы.ТаблицаТоваров.Скопировать(,СтрокаПроизвольныхПолей);
	
	Для Сч=0 По ТаблицаОсновныхПолей.Количество()-1 Цикл
		
		СтруктураДокумента = СтрокаТаблицыВСтруктуру(ТаблицаОсновныхПолей[Сч]);
		СтруктураДокумента.Вставить("ПроизвольныеПоля", СтрокаТаблицыВСтруктуру(ТаблицаПроизвольныхПолей[Сч]));
		//здесь надо вычленить все доп.поля в отдельный вложенный массив
		//а человеческие имена этих полей дадим в отдельной сущности: каталоги
		
		ИДТовара = ТаблицаОсновныхПолей[Сч].Код;
		ES_API_Goods_Create(ИДТовара,СтруктураВJSON(СтруктураДокумента));
		
		//Прервать;//отладка
		
	КонецЦикла;
	
	//итак, нам надо:
	//1. Иметь всегда актуальные GUID для каталогов. Возможно, их не удастся извлечь из файла (на это должен быть расчет).
	// А это значит, что нужно отдельное API на входе.
	// Или как раз задействовать 1С для хранения таблицы каталогов и организаций.
	// Т.е. мы не просто помещаем внутрь новый каталог, а помещаем его в определенный GUID.
	// Кто присвоит гуид? 1С присвоит.
	// Т.е. API должно выглядеть примерно так:
	// POST /cat/<guid>	(причем с обязательной проверкой прав доступа)
	// GET /cat/<guid>	(вернет CommerceML нужного каталога. Поштучного скачивания товаров пока не предполагаем)
	// GET /cat/_list	(вернет перечень существующих каталогов. Конечно же, надо фильтровать, например, по тегам.)
	
	//рендерить будем в json или xml? Если обойтись Структурами и Массивами, то родным будет json, а xml из него получится довольно просто
	
	//нужен апач, очень сильно.
	
	// и вообще намечается нормальная структура
	
	
	// теперь. API можно пока реализовать и на 1С. А будет ли толк при локальной установке?
	// И насколько легко портировать API на Node.js, например? И надо ли вообще?
	
	// Ладно, а если из соображений лицензионности пока реализовать API на Node.js и оставить 1С обычным "демоном", который поедает файлы из директорий
	// и уже перерабатывает их в ES?
	
	
	
КонецПроцедуры

